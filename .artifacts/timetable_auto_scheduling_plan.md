# ‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
# Auto Timetable Scheduling System

## üìã ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£

‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô/‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ï‡πà‡∏≤‡∏á ‡πÜ ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡∏ß‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡∏•‡∏∞‡∏Ñ‡∏≤‡∏ö

## üéØ ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå

1. **‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á** ‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ô‡∏≤‡∏ó‡∏µ
2. **‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î** ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡∏£‡∏π‡∏™‡∏≠‡∏ô‡∏ã‡πâ‡∏≠‡∏ô, ‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≠‡∏ô
3. **‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏Ñ‡∏≤‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•** ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô
4. **‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏£‡∏π** ‡πÄ‡∏ä‡πà‡∏ô ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏î‡∏ß‡∏Å, ‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£

## üèóÔ∏è ‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏°‡∏£‡∏∞‡∏ö‡∏ö

### Phase 1: Database Schema Extensions (1-2 ‡∏ß‡∏±‡∏ô)

#### 1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≤‡∏£‡∏≤‡∏á Scheduling Preferences

```sql
-- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏£‡∏π‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô
CREATE TABLE instructor_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instructor_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    academic_year_id UUID NOT NULL REFERENCES academic_years(id) ON DELETE CASCADE,
    
    -- Unavailable slots (JSON array of {day, period_id})
    unavailable_slots JSONB DEFAULT '[]'::jsonb,
    
    -- Preferred slots (JSON array of {day, period_id})
    preferred_slots JSONB DEFAULT '[]'::jsonb,
    
    -- Maximum periods per day
    max_periods_per_day INTEGER DEFAULT 6,
    
    -- Maximum consecutive periods
    max_consecutive_periods INTEGER DEFAULT 3,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(instructor_id, academic_year_id)
);

-- Subject Constraints (‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏ä‡∏≤)
CREATE TABLE subject_constraints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    subject_id UUID NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
    academic_year_id UUID NOT NULL REFERENCES academic_years(id) ON DELETE CASCADE,
    
    -- ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    preferred_time_of_day VARCHAR(20), -- 'MORNING', 'AFTERNOON', 'ANY'
    
    -- ‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    required_room_type VARCHAR(50), -- 'LAB', 'COMPUTER', 'GYM', NULL
    
    -- ‡∏Ñ‡∏ß‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô
    scheduling_pattern VARCHAR(20) DEFAULT 'DISTRIBUTED', -- 'DISTRIBUTED', 'CONSECUTIVE', 'ANY'
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(subject_id, academic_year_id)
);

-- Scheduling Jobs (‡πÄ‡∏Å‡πá‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£ generate)
CREATE TABLE timetable_scheduling_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    classroom_id UUID REFERENCES class_rooms(id) ON DELETE SET NULL,
    academic_semester_id UUID NOT NULL REFERENCES academic_semesters(id) ON DELETE CASCADE,
    
    -- Scope
    scope VARCHAR(20) NOT NULL, -- 'SINGLE_CLASSROOM', 'GRADE_LEVEL', 'ALL_SCHOOL'
    scope_ids JSONB, -- array of classroom_ids if applicable
    
    -- Status
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING', -- 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED'
    
    -- Results
    total_courses INTEGER DEFAULT 0,
    scheduled_courses INTEGER DEFAULT 0,
    failed_courses INTEGER DEFAULT 0,
    
    -- Configuration
    config JSONB DEFAULT '{}'::jsonb, -- {force: bool, optimize: bool, etc.}
    
    -- Error/Warnings
    error_message TEXT,
    warnings JSONB DEFAULT '[]'::jsonb,
    
    -- Timing
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

#### 1.2 ‡πÄ‡∏û‡∏¥‡πà‡∏° metadata ‡πÉ‡∏ô subjects table

```sql
-- Add to existing subjects table
ALTER TABLE subjects 
ADD COLUMN IF NOT EXISTS periods_per_week INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS min_consecutive_periods INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS max_consecutive_periods INTEGER DEFAULT 2;

COMMENT ON COLUMN subjects.periods_per_week IS '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡∏°‡∏µ (0 = calculate from hours/credit)';
COMMENT ON COLUMN subjects.min_consecutive_periods IS '‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (‡πÄ‡∏ä‡πà‡∏ô ‡∏û‡∏•‡∏∞‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô)';
COMMENT ON COLUMN subjects.max_consecutive_periods IS '‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡∏ô‡∏µ‡πâ)';
```

### Phase 2: Backend Auto-Scheduling Algorithm (3-5 ‡∏ß‡∏±‡∏ô)

#### 2.1 ‡∏™‡∏£‡πâ‡∏≤‡∏á Scheduling Service

**File: `backend-school/src/modules/academic/services/auto_scheduler.rs`**

```rust
// Core structures
pub struct SchedulingRequest {
    pub classroom_ids: Vec<Uuid>,
    pub semester_id: Uuid,
    pub config: SchedulingConfig,
}

pub struct SchedulingConfig {
    pub force_overwrite: bool,          // ‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    pub optimize_level: OptimizeLevel,  // FAST, BALANCED, BEST
    pub respect_preferences: bool,      // ‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á preferences ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏£‡∏π‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    pub max_iterations: u32,            // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≠‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°
}

pub struct TimeSlot {
    pub day: DayOfWeek,
    pub period_id: Uuid,
}

pub struct SchedulingConstraints {
    pub hard_constraints: Vec<HardConstraint>,
    pub soft_constraints: Vec<SoftConstraint>,
}

// Main algorithm
impl AutoScheduler {
    /// Main entry point
    pub async fn generate_timetable(
        pool: &PgPool,
        request: SchedulingRequest,
    ) -> Result<SchedulingResult> {
        let job_id = Self::create_job(pool, &request).await?;
        
        // 1. Gather all data
        let courses = Self::get_courses_to_schedule(pool, &request).await?;
        let periods = Self::get_available_periods(pool, &request).await?;
        let constraints = Self::build_constraints(pool, &request).await?;
        
        // 2. Run scheduling algorithm
        let assignments = match request.config.optimize_level {
            OptimizeLevel::FAST => Self::greedy_schedule(&courses, &periods, &constraints)?,
            OptimizeLevel::BALANCED => Self::backtracking_schedule(&courses, &periods, &constraints)?,
            OptimizeLevel::BEST => Self::simulated_annealing_schedule(&courses, &periods, &constraints)?,
        };
        
        // 3. Save to database
        Self::save_timetable(pool, &assignments, &request).await?;
        
        // 4. Update job status
        Self::complete_job(pool, job_id, &assignments).await?;
        
        Ok(SchedulingResult {
            job_id,
            scheduled: assignments.len(),
            failed: courses.len() - assignments.len(),
        })
    }
    
    /// Greedy algorithm (‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
    fn greedy_schedule(
        courses: &[CourseToSchedule],
        periods: &[TimeSlot],
        constraints: &SchedulingConstraints,
    ) -> Result<Vec<Assignment>> {
        let mut assignments = Vec::new();
        let mut occupied = HashMap::new();
        
        // Sort courses by difficulty (‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏≤‡∏Å‡∏à‡∏±‡∏î‡∏Å‡πà‡∏≠‡∏ô)
        let mut sorted_courses = courses.to_vec();
        sorted_courses.sort_by_key(|c| {
            // ‡∏¢‡∏≤‡∏Å‡∏ñ‡πâ‡∏≤: ‡∏Ñ‡∏£‡∏π‡∏™‡∏≠‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á, ‡∏ß‡∏¥‡∏ä‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏¢‡∏≠‡∏∞, ‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ô‡πâ‡∏≠‡∏¢
            -(c.constraint_count() as i32)
        });
        
        for course in sorted_courses {
            // Find first available slot that satisfies constraints
            if let Some(slot) = Self::find_best_slot(&course, periods, &occupied, constraints) {
                assignments.push(Assignment {
                    course_id: course.id,
                    time_slot: slot.clone(),
                    room_id: Self::assign_room(&course, &slot, &occupied)?,
                });
                Self::mark_occupied(&mut occupied, &slot, &course);
            } else {
                // Cannot schedule this course
                warn!("Cannot schedule course: {:?}", course);
            }
        }
        
        Ok(assignments)
    }
    
    /// Backtracking algorithm (‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ greedy, ‡∏´‡∏≤‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô)
    fn backtracking_schedule(
        courses: &[CourseToSchedule],
        periods: &[TimeSlot],
        constraints: &SchedulingConstraints,
    ) -> Result<Vec<Assignment>> {
        let mut assignments = Vec::new();
        let mut occupied = HashMap::new();
        
        if Self::backtrack(courses, 0, periods, constraints, &mut assignments, &mut occupied) {
            Ok(assignments)
        } else {
            Err(AppError::BadRequest("Cannot find valid schedule".to_string()))
        }
    }
    
    fn backtrack(
        courses: &[CourseToSchedule],
        index: usize,
        periods: &[TimeSlot],
        constraints: &SchedulingConstraints,
        assignments: &mut Vec<Assignment>,
        occupied: &mut HashMap<String, CourseInfo>,
    ) -> bool {
        // Base case: all courses scheduled
        if index >= courses.len() {
            return true;
        }
        
        let course = &courses[index];
        
        // Try each possible slot
        for slot in periods {
            if Self::is_valid_assignment(course, slot, occupied, constraints) {
                // Make assignment
                let assignment = Assignment {
                    course_id: course.id,
                    time_slot: slot.clone(),
                    room_id: Self::assign_room(course, slot, occupied).ok(),
                };
                assignments.push(assignment.clone());
                Self::mark_occupied(occupied, slot, course);
                
                // Recurse
                if Self::backtrack(courses, index + 1, periods, constraints, assignments, occupied) {
                    return true;
                }
                
                // Undo (backtrack)
                assignments.pop();
                Self::unmark_occupied(occupied, slot, course);
            }
        }
        
        false
    }
    
    /// Check hard constraints
    fn is_valid_assignment(
        course: &CourseToSchedule,
        slot: &TimeSlot,
        occupied: &HashMap<String, CourseInfo>,
        constraints: &SchedulingConstraints,
    ) -> bool {
        // 1. Classroom conflict
        let classroom_key = format!("classroom_{}_{}", course.classroom_id, slot.key());
        if occupied.contains_key(&classroom_key) {
            return false;
        }
        
        // 2. Instructor conflict
        if let Some(instructor_id) = course.instructor_id {
            let instructor_key = format!("instructor_{}_{}", instructor_id, slot.key());
            if occupied.contains_key(&instructor_key) {
                return false;
            }
            
            // 3. Instructor preferences
            if let Some(prefs) = constraints.instructor_prefs.get(&instructor_id) {
                if prefs.unavailable_slots.contains(slot) {
                    return false;
                }
            }
        }
        
        // 4. Room conflict (if requires special room)
        if let Some(required_room_type) = &course.required_room_type {
            // Check if any room of this type is available
            if !Self::has_available_room(required_room_type, slot, occupied) {
                return false;
            }
        }
        
        // 5. Subject constraints
        if let Some(subject_constraints) = constraints.subject_constraints.get(&course.subject_id) {
            // Check time of day preference
            if let Some(pref_time) = &subject_constraints.preferred_time_of_day {
                if !Self::matches_time_preference(slot, pref_time) {
                    // This is soft constraint in some cases, hard in others
                    // For now, treat as soft (allow but penalize)
                }
            }
        }
        
        true
    }
    
    /// Calculate quality score (for optimization)
    fn calculate_score(
        assignments: &[Assignment],
        constraints: &SchedulingConstraints,
    ) -> f64 {
        let mut score = 0.0;
        
        // Positive: spread well, respects preferences
        // Negative: too many consecutive, ignores preferences
        
        // TODO: Implement scoring heuristics
        
        score
    }
}
```

#### 2.2 ‡∏™‡∏£‡πâ‡∏≤‡∏á API Handlers

**File: `backend-school/src/modules/academic/handlers/auto_scheduler.rs`**

```rust
/// POST /api/academic/timetable/auto-generate
pub async fn auto_generate_timetable(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<AutoGenerateRequest>,
) -> Result<impl IntoResponse, AppError> {
    let pool = get_pool(&state, &headers)?;
    check_permission(&pool, &headers, "academic:timetable:manage").await?;
    
    let request = SchedulingRequest {
        classroom_ids: payload.classroom_ids,
        semester_id: payload.semester_id,
        config: SchedulingConfig {
            force_overwrite: payload.force.unwrap_or(false),
            optimize_level: payload.optimize_level.unwrap_or(OptimizeLevel::BALANCED),
            respect_preferences: payload.respect_preferences.unwrap_or(true),
            max_iterations: payload.max_iterations.unwrap_or(1000),
        },
    };
    
    // Run async (for large schools, this may take time)
    let result = AutoScheduler::generate_timetable(&pool, request).await?;
    
    Ok(Json(json!({
        "success": true,
        "job_id": result.job_id,
        "scheduled": result.scheduled,
        "failed": result.failed,
    })))
}

/// GET /api/academic/timetable/jobs/{job_id}
pub async fn get_scheduling_job(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(job_id): Path<Uuid>,
) -> Result<impl IntoResponse, AppError> {
    let pool = get_pool(&state, &headers)?;
    
    let job = sqlx::query_as::<_, SchedulingJob>(
        "SELECT * FROM timetable_scheduling_jobs WHERE id = $1"
    )
    .bind(job_id)
    .fetch_one(&pool)
    .await?;
    
    Ok(Json(job))
}
```

### Phase 3: Frontend UI (2-3 ‡∏ß‡∏±‡∏ô)

#### 3.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° "‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥" ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ Timetable

**File: `frontend-school/src/routes/(app)/staff/academic/timetable/+page.svelte`**

‡πÄ‡∏û‡∏¥‡πà‡∏° UI components:
1. ‡∏õ‡∏∏‡πà‡∏° "ü§ñ ‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥" ‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏Ç‡∏ß‡∏≤
2. Dialog ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤:
   - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô (1 ‡∏´‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏•‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á)
   - ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Optimize (‡πÄ‡∏£‡πá‡∏ß / ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á / ‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
   - ‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
   - ‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏£‡∏π‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
3. Progress indicator ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á generate
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ä‡∏≤, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ä‡∏≤)

```svelte
<script lang="ts">
    // ... existing code ...
    
    let showAutoScheduleModal = $state(false);
    let autoScheduleClassrooms = $state<string[]>([]);
    let autoScheduleOptimize = $state<'FAST' | 'BALANCED' | 'BEST'>('BALANCED');
    let autoScheduleForce = $state(false);
    let autoScheduleRunning = $state(false);
    
    async function handleAutoSchedule() {
        if (autoScheduleClassrooms.length === 0) {
            toast.error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏´‡πâ‡∏≠‡∏á');
            return;
        }
        
        try {
            autoScheduleRunning = true;
            
            const response = await autoGenerateTimetable({
                classroom_ids: autoScheduleClassrooms,
                semester_id: selectedSemesterId,
                force: autoScheduleForce,
                optimize_level: autoScheduleOptimize,
                respect_preferences: true,
            });
            
            if (response.success) {
                toast.success(`‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${response.scheduled} ‡∏ß‡∏¥‡∏ä‡∏≤`);
                if (response.failed > 0) {
                    toast.warning(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏±‡∏î ${response.failed} ‡∏ß‡∏¥‡∏ä‡∏≤`);
                }
                await loadTimetable();
                showAutoScheduleModal = false;
            }
        } catch (e: any) {
            toast.error(e.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î');
        } finally {
            autoScheduleRunning = false;
        }
    }
</script>

<!-- Add button in header -->
<Button onclick={() => showAutoScheduleModal = true}>
    <Sparkles class="w-4 h-4 mr-2" />
    ‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
</Button>

<!-- Auto Schedule Dialog -->
<Dialog.Root bind:open={showAutoScheduleModal}>
    <Dialog.Content class="max-w-2xl">
        <Dialog.Header>
            <Dialog.Title>ü§ñ ‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</Dialog.Title>
            <Dialog.Description>
                ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏´‡πâ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ï‡πà‡∏≤‡∏á ‡πÜ
            </Dialog.Description>
        </Dialog.Header>
        
        <div class="space-y-4">
            <!-- Classroom Selection -->
            <div>
                <Label.Root>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô</Label.Root>
                <div class="grid grid-cols-2 gap-2 mt-2 max-h-64 overflow-y-auto">
                    {#each classrooms as classroom}
                        <label class="flex items-center gap-2 p-2 border rounded hover:bg-accent cursor-pointer">
                            <Checkbox
                                checked={autoScheduleClassrooms.includes(classroom.id)}
                                onCheckedChange={(checked) => {
                                    if (checked) {
                                        autoScheduleClassrooms = [...autoScheduleClassrooms, classroom.id];
                                    } else {
                                        autoScheduleClassrooms = autoScheduleClassrooms.filter(id => id !== classroom.id);
                                    }
                                }}
                            />
                            <span class="text-sm">{classroom.name}</span>
                        </label>
                    {/each}
                </div>
            </div>
            
            <!-- Optimize Level -->
            <div>
                <Label.Root>‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°</Label.Root>
                <Select.Root bind:value={autoScheduleOptimize}>
                    <Select.Trigger>
                        <Select.Value />
                    </Select.Trigger>
                    <Select.Content>
                        <Select.Item value="FAST">‡πÄ‡∏£‡πá‡∏ß (‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)</Select.Item>
                        <Select.Item value="BALANCED">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)</Select.Item>
                        <Select.Item value="BEST">‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô)</Select.Item>
                    </Select.Content>
                </Select.Root>
            </div>
            
            <!-- Force Overwrite -->
            <label class="flex items-center gap-2">
                <Checkbox bind:checked={autoScheduleForce} />
                <span class="text-sm">‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</span>
            </label>
        </div>
        
        <Dialog.Footer>
            <Button variant="outline" onclick={() => showAutoScheduleModal = false}>
                ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
            </Button>
            <Button 
                onclick={handleAutoSchedule}
                disabled={autoScheduleRunning || autoScheduleClassrooms.length === 0}
            >
                {#if autoScheduleRunning}
                    <Loader2 class="w-4 h-4 mr-2 animate-spin" />
                    ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á...
                {:else}
                    ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á
                {/if}
            </Button>
        </Dialog.Footer>
    </Dialog.Content>
</Dialog.Root>
```

#### 3.2 ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤ Preferences Management (Optional ‡πÅ‡∏ï‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)

**File: `frontend-school/src/routes/(app)/staff/academic/scheduling-preferences/+page.svelte`**

‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏π‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤:
- ‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏™‡∏≠‡∏ô
- ‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ô
- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô

### Phase 4: Testing & Optimization (2-3 ‡∏ß‡∏±‡∏ô)

1. **Unit Tests** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö algorithm
2. **Integration Tests** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API
3. **Performance Testing** ‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á (100+ ‡∏´‡πâ‡∏≠‡∏á, 1000+ ‡∏ß‡∏¥‡∏ä‡∏≤)
4. **User Acceptance Testing** ‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏£‡∏¥‡∏á

## üìä ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Algorithm Flow

```
1. Input:
   - Classroom: ‡∏°.4/1 (30 ‡∏Ñ‡∏ô)
   - Semester: 1/2568
   - Courses: 
     * ‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå, ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢)
     * ‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå, ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á)
     * ‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå, ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢, ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ LAB)
     * ...‡∏£‡∏ß‡∏° 15 ‡∏ß‡∏¥‡∏ä‡∏≤

2. Build Timetable Grid:
   - Days: MON-FRI (5 ‡∏ß‡∏±‡∏ô)
   - Periods: 8 ‡∏Ñ‡∏≤‡∏ö/‡∏ß‡∏±‡∏ô
   - Total slots: 40 ‡∏ä‡πà‡∏≠‡∏á

3. Sort Courses by Difficulty:
   - ‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (‡∏¢‡∏≤‡∏Å‡∏™‡∏∏‡∏î: ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ LAB, ‡∏Ñ‡∏£‡∏π‡∏™‡∏≠‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á)
   - ‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (‡∏Ñ‡∏£‡∏π‡∏™‡∏≠‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á)
   - ‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
   - ...

4. Schedule (Greedy):
   For each course:
     For each period needed:
       Find first available slot where:
         ‚úÖ ‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á
         ‚úÖ ‡∏Ñ‡∏£‡∏π‡∏ß‡πà‡∏≤‡∏á
         ‚úÖ LAB ‡∏ß‡πà‡∏≤‡∏á (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
         ‚úÖ ‡πÑ‡∏°‡πà‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ö preferences
         ‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ 4 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
       Assign ‚Üí Mark as occupied

5. Output:
   - Success: 58/60 ‡∏Ñ‡∏≤‡∏ö (97%)
   - Failed: 2 ‡∏ß‡∏¥‡∏ä‡∏≤ (‡∏û‡∏•‡∏∞ 2 ‡∏Ñ‡∏≤‡∏ö - ‡∏™‡∏ô‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á)
```

## ‚ö° Optimization Strategies

### 1. **Pre-computation**
- Cache instructor availability
- Pre-filter impossible slots
- Build conflict graph

### 2. **Heuristics**
- **Most Constrained First**: ‡∏à‡∏±‡∏î‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏≤‡∏Å‡∏Å‡πà‡∏≠‡∏ô
- **Least Constraining Value**: ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å slot ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
- **Random Restart**: ‡∏ñ‡πâ‡∏≤‡∏ï‡∏¥‡∏î‡∏Å‡πá‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢ random seed ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô

### 3. **Parallel Processing** (Advanced)
- ‡πÅ‡∏¢‡∏Å‡∏à‡∏±‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ä‡∏±‡πâ‡∏ô‡∏õ‡∏µ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô (‡πÑ‡∏°‡πà‡∏°‡∏µ conflict ‡∏Ç‡πâ‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô)
- ‡πÉ‡∏ä‡πâ Web Workers / Background Jobs

## üöÄ Deployment Plan

### MVP (Minimum Viable Product) - 7-10 ‡∏ß‡∏±‡∏ô
- ‚úÖ Basic greedy algorithm
- ‚úÖ Hard constraints only
- ‚úÖ Single classroom scheduling
- ‚úÖ Simple UI

### V1.0 - 14-21 ‡∏ß‡∏±‡∏ô (Full Features)
- ‚úÖ Backtracking algorithm
- ‚úÖ Soft constraints
- ‚úÖ Batch scheduling (multiple classrooms)
- ‚úÖ Preferences management
- ‚úÖ Result visualization

### V2.0 - Future
- ‚úÖ Machine Learning optimization
- ‚úÖ Historical data analysis
- ‚úÖ Conflict resolution suggestions
- ‚úÖ What-if analysis

## üéì ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```typescript
// 1. Auto-generate for single classroom
await autoGenerateTimetable({
    classroom_ids: ['uuid-m4-1'],
    semester_id: 'uuid-sem-1-2568',
    optimize_level: 'BALANCED'
});

// 2. Auto-generate for entire grade level
const m4Classrooms = classrooms.filter(c => c.grade_level === 'M4');
await autoGenerateTimetable({
    classroom_ids: m4Classrooms.map(c => c.id),
    semester_id: 'uuid-sem-1-2568',
    force: true, // Clear existing
    optimize_level: 'BEST'
});

// 3. Check job status
const job = await getSchedulingJob('uuid-job-123');
console.log(`Status: ${job.status}, Progress: ${job.scheduled}/${job.total_courses}`);
```

## üéØ Success Metrics

1. **Scheduling Success Rate**: > 95% of courses scheduled
2. **Performance**: < 30 seconds for 50 classrooms
3. **User Satisfaction**: Reduce manual work by > 80%
4. **Accuracy**: Zero hard constraint violations

## üìö References

- [Constraint Satisfaction Problems](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem)
- [Timetabling Problem](https://en.wikipedia.org/wiki/Timetabling)
- [Simulated Annealing](https://en.wikipedia.org/wiki/Simulated_annealing)
- [Genetic Algorithms for Timetabling](https://arxiv.org/abs/1903.07265)

---

**‡∏ó‡∏µ‡∏°‡∏û‡∏±‡∏í‡∏ô‡∏≤**: SchoolOrbit Development Team
**‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á**: 2026-02-08
**‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô**: 1.0 (Draft)
