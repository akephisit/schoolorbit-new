# üéØ Advanced Timetable Constraints
## ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥

> **‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏à‡∏≤‡∏Å‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å**: ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏à‡∏£‡∏¥‡∏á

---

## üìå New Advanced Constraints

### **HC-7: Consecutive Period Requirements** üî¥ HARD
**‡∏Å‡∏é**: ‡∏ö‡∏≤‡∏á‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÉ‡∏î ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î

#### **‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç! ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á "‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô":**
```
"‡∏ß‡∏¥‡∏ä‡∏≤‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î" ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á:
  ‚Üí ‡∏ß‡∏±‡∏ô‡πÑ‡∏´‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
  ‚Üí ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
  ‚Üí ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡πÑ‡∏î‡πâ

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á - ‡∏û‡∏•‡∏∞ 3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå, ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î:
  ‚úÖ ‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏û‡∏•‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
  ‚úÖ ‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 3: ‡∏û‡∏•‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß - OK!)
  
  ‚ùå ‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5: ‡∏û‡∏•‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö)
  ‚ùå ‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 3-4: ‡∏û‡∏•‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö)
     ‚Üí ‡∏ú‡∏¥‡∏î! ‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á - ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏°‡∏µ 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå, ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î:
  ‚úÖ ‡∏ß‡∏±‡∏ô‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-4: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
  ‚úÖ ‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 5-6: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
  
  ‚ùå ‡∏ß‡∏±‡∏ô‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-5: LAB (3 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
  ‚ùå ‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 7: LAB (1 ‡∏Ñ‡∏≤‡∏ö)
     ‚Üí ‡∏ú‡∏¥‡∏î! ‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
```

#### **Use Cases:**
```
‚úÖ ‡∏û‡∏•‡∏∞ 2-3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á (‡∏≠‡∏∏‡πà‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á + ‡πÄ‡∏•‡πà‡∏ô + ‡∏≠‡∏≤‡∏ö‡∏ô‡πâ‡∏≥)
‚úÖ ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ó‡∏¢‡πå 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á (‡∏ï‡∏±‡πâ‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå + ‡∏ó‡∏î‡∏•‡∏≠‡∏á)
‚úÖ ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≠‡∏° 3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á (‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° + ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)
‚úÖ ‡∏®‡∏¥‡∏•‡∏õ‡∏∞ 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á (‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡∏≠‡∏á + ‡∏ù‡∏∂‡∏Å)

‚ùå ‡∏Ñ‡∏ì‡∏¥‡∏ï, ‡πÑ‡∏ó‡∏¢, ‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©: ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö (‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏Ñ‡∏≤‡∏ö‡πÑ‡∏î‡πâ)
```

#### **Database Schema:**

```sql
-- Add to subjects table
ALTER TABLE subjects 
ADD COLUMN IF NOT EXISTS min_consecutive_periods INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS max_consecutive_periods INTEGER DEFAULT 2,
ADD COLUMN IF NOT EXISTS allow_single_period BOOLEAN DEFAULT true;

COMMENT ON COLUMN subjects.min_consecutive_periods IS '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô (1=‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö, 2+=‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô)';
COMMENT ON COLUMN subjects.max_consecutive_periods IS '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô';
COMMENT ON COLUMN subjects.allow_single_period IS '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠)';

-- Examples:

-- 1. ‡∏û‡∏•‡∏∞: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î, ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠)
UPDATE subjects SET 
    min_consecutive_periods = 2,
    max_consecutive_periods = 2,
    allow_single_period = true  -- ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
WHERE subject_type = 'PE';

/* 
   ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ñ‡πå - ‡∏û‡∏•‡∏∞ 3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå:
   ‚úÖ ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏û‡∏•‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
   ‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 3: ‡∏û‡∏•‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß - OK!)
*/

-- 2. ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£ LAB: ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î, ‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
UPDATE subjects SET 
    min_consecutive_periods = 2,
    max_consecutive_periods = 3,
    allow_single_period = false  -- ‡∏´‡πâ‡∏≤‡∏° 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
WHERE code LIKE 'LAB%';

/*
   ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ñ‡πå - ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏°‡∏µ 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå:
   ‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-4: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
   ‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 5-6: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
   ‚ùå ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-5: LAB (3 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
   ‚ùå ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 7: LAB (1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß - ‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï!)
*/

-- 3. ‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ: ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
UPDATE subjects SET 
    min_consecutive_periods = 1,  -- ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö
    max_consecutive_periods = 2,
    allow_single_period = true
WHERE subject_type = 'CORE';

/*
   ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ñ‡πå - ‡∏Ñ‡∏ì‡∏¥‡∏ï 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå:
   ‚úÖ ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 1: ‡∏Ñ‡∏ì‡∏¥‡∏ï (1 ‡∏Ñ‡∏≤‡∏ö OK)
   ‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-4: ‡∏Ñ‡∏ì‡∏¥‡∏ï (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î OK)
   ‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 7: ‡∏Ñ‡∏ì‡∏¥‡∏ï (1 ‡∏Ñ‡∏≤‡∏ö OK)
*/
```

#### **Implementation:**

```rust
struct ConsecutiveRequirement {
    subject_id: Uuid,
    min_consecutive: i32,      // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (‡πÄ‡∏ä‡πà‡∏ô 2)
    max_consecutive: i32,      // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡πÄ‡∏ä‡πà‡∏ô 2)
    allow_single_period: bool, // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠)
}

fn validate_consecutive_periods(
    course: &CourseToSchedule,
    assignments: &[Assignment],
    requirement: &ConsecutiveRequirement,
) -> Result<(), String> {
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö consecutive = ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ä‡πá‡∏Ñ
    if requirement.min_consecutive <= 1 {
        return Ok(());
    }
    
    // Group assignments by day
    let assignments_by_day = group_by_day(assignments);
    
    // Check each day separately
    for (day, day_assignments) in assignments_by_day {
        let period_count = day_assignments.len() as i32;
        
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏Ñ‡πà 1 ‡∏Ñ‡∏≤‡∏ö‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
        if period_count == 1 {
            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡πÑ‡∏´‡∏°
            if !requirement.allow_single_period {
                return Err(format!(
                    "Subject {} requires at least {} consecutive periods per day, but {} has only 1 period",
                    course.subject_code,
                    requirement.min_consecutive,
                    day
                ));
            }
            // OK - ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠)
            continue;
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ 2 ‡∏Ñ‡∏≤‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡πÑ‡∏´‡∏°
        let periods = get_period_numbers(&day_assignments);
        
        // Check if consecutive
        if !is_consecutive(&periods) {
            return Err(format!(
                "Subject {} periods on {} must be consecutive, got {:?}",
                course.subject_code,
                day,
                periods
            ));
        }
        
        // Check min/max consecutive
        if period_count < requirement.min_consecutive {
            return Err(format!(
                "Subject {} requires at least {} consecutive periods on {}, got {}",
                course.subject_code,
                requirement.min_consecutive,
                day,
                period_count
            ));
        }
        
        if period_count > requirement.max_consecutive {
            return Err(format!(
                "Subject {} allows max {} consecutive periods on {}, got {}",
                course.subject_code,
                requirement.max_consecutive,
                day,
                period_count
            ));
        }
    }
    
    Ok(())
}

// Helper: check if period numbers are consecutive
fn is_consecutive(periods: &[i32]) -> bool {
    if periods.len() <= 1 {
        return true;
    }
    
    let mut sorted = periods.to_vec();
    sorted.sort();
    
    for i in 1..sorted.len() {
        if sorted[i] != sorted[i-1] + 1 {
            return false; // Gap found
        }
    }
    
    true
}

// During scheduling, must ensure consecutive periods
fn schedule_course_with_consecutive(
    course: &CourseToSchedule,
    time_slots: &[TimeSlot],
    requirement: &ConsecutiveRequirement,
) -> Result<Vec<Assignment>, AppError> {
    let periods_needed = course.periods_needed;
    let min_consecutive = requirement.min_consecutive;
    
    // If must be consecutive
    if min_consecutive > 1 {
        // Try to find consecutive slots
        return schedule_consecutive_slots(
            course,
            time_slots,
            periods_needed,
            min_consecutive,
        );
    } else {
        // Can be split
        return schedule_normal(course, time_slots, periods_needed);
    }
}

fn schedule_consecutive_slots(
    course: &CourseToSchedule,
    time_slots: &[TimeSlot],
    total_needed: i32,
    consecutive_size: i32,
) -> Result<Vec<Assignment>, AppError> {
    let mut assignments = Vec::new();
    let mut remaining = total_needed;
    
    // Group slots by day
    let slots_by_day = group_slots_by_day(time_slots);
    
    while remaining > 0 {
        let chunk_size = consecutive_size.min(remaining);
        
        // Find consecutive slots
        for (day, day_slots) in &slots_by_day {
            if let Some(consecutive_slots) = find_consecutive_available_slots(
                day_slots,
                chunk_size as usize,
            ) {
                // Assign these slots
                for slot in consecutive_slots {
                    assignments.push(Assignment {
                        course_id: course.id,
                        time_slot: slot.clone(),
                        room_id: None,
                    });
                }
                remaining -= chunk_size;
                break;
            }
        }
        
        if remaining > 0 && remaining == total_needed {
            // Could not find any consecutive slots
            return Err(AppError::BadRequest(format!(
                "Cannot find {} consecutive periods for {}",
                consecutive_size, course.subject_code
            )));
        }
    }
    
    Ok(assignments)
}

fn find_consecutive_available_slots(
    slots: &[TimeSlot],
    count: usize,
) -> Option<Vec<TimeSlot>> {
    // Sort by period order
    let mut sorted_slots = slots.to_vec();
    sorted_slots.sort_by_key(|s| get_period_order(&s.period_id));
    
    // Find consecutive window
    for i in 0..=sorted_slots.len().saturating_sub(count) {
        let window = &sorted_slots[i..i + count];
        
        // Check if truly consecutive
        if is_consecutive_periods(window) {
            return Some(window.to_vec());
        }
    }
    
    None
}
```

#### **Examples:**

```rust
// Example 1: ‡∏û‡∏•‡∏∞ 3 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå - ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î, ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
ConsecutiveRequirement {
    subject_id: pe_subject_id,
    min_consecutive: 2,
    max_consecutive: 2,
    allow_single_period: true, // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏û‡∏•‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î - ‡∏î‡∏µ!)
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 3: ‡∏û‡∏•‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß - OK ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ allow_single_period = true)

‚ùå ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5: ‡∏û‡∏•‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö)
   ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 3-4: ‡∏û‡∏•‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö)
   ‚Üí ‡∏ú‡∏¥‡∏î! ‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡∏°‡∏µ 1 ‡∏Ñ‡∏≤‡∏ö ‡πÅ‡∏ï‡πà allow_single_period = true ‡∏Ñ‡∏ß‡∏£‡∏à‡∏±‡∏î 2 ‡∏Ñ‡∏≤‡∏ö‡πÉ‡∏´‡πâ

‚ùå ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5-7: ‡∏û‡∏•‡∏∞ (3 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
   ‚Üí ‡∏ú‡∏¥‡∏î! ‡πÄ‡∏Å‡∏¥‡∏ô max_consecutive (2)

---

// Example 2: ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏°‡∏µ 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå - ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î, ‡∏´‡πâ‡∏≤‡∏° 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
ConsecutiveRequirement {
    subject_id: chem_lab_id,
    min_consecutive: 2,
    max_consecutive: 3,
    allow_single_period: false, // ‡∏´‡πâ‡∏≤‡∏° 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-4: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 5-6: LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)

‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-5: LAB (3 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î - OK, ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô max)
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 6: LAB (1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß... ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß!)
   ‚Üí ‡∏ú‡∏¥‡∏î! allow_single_period = false ‡∏´‡πâ‡∏≤‡∏° 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß

---

// Example 3: ‡∏Ñ‡∏ì‡∏¥‡∏ï 4 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå - ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
ConsecutiveRequirement {
    subject_id: math_id,
    min_consecutive: 1, // ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö
    max_consecutive: 2,
    allow_single_period: true,
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 1: ‡∏Ñ‡∏ì‡∏¥‡∏ï (1 ‡∏Ñ‡∏≤‡∏ö OK)
‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏Ñ‡∏≤‡∏ö 3-4: ‡∏Ñ‡∏ì‡∏¥‡∏ï (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î OK)
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 7: ‡∏Ñ‡∏ì‡∏¥‡∏ï (1 ‡∏Ñ‡∏≤‡∏ö OK)
‚Üí ‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á OK ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ min_consecutive = 1 (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô)

---

// Example 4: ‡∏®‡∏¥‡∏•‡∏õ‡∏∞ 2 ‡∏Ñ‡∏≤‡∏ö/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå - ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î, ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
ConsecutiveRequirement {
    subject_id: art_id,
    min_consecutive: 2,
    max_consecutive: 2,
    allow_single_period: false, // ‡∏´‡πâ‡∏≤‡∏° 1 ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏®‡∏¥‡∏•‡∏õ‡∏∞ (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î)
‚Üí Perfect! ‡∏Ñ‡∏£‡∏ö 2 ‡∏Ñ‡∏≤‡∏ö‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß

‚ùå ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 5: ‡∏®‡∏¥‡∏•‡∏õ‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö)
   ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏Ñ‡∏≤‡∏ö 6: ‡∏®‡∏¥‡∏•‡∏õ‡∏∞ (1 ‡∏Ñ‡∏≤‡∏ö)
   ‚Üí ‡∏ú‡∏¥‡∏î! allow_single_period = false ‡∏´‡πâ‡∏≤‡∏°‡πÅ‡∏¢‡∏Å
```

**Priority**: üî¥ Critical (for specific subjects)
**Enforcement**: Hard constraint for subjects with `force_consecutive = true`

---

### **HC-8: Fixed Room Assignment** üî¥ HARD
**‡∏Å‡∏é**: ‡∏ö‡∏≤‡∏á‡∏Ñ‡∏£‡∏π‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≠‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏™‡∏°‡∏≠

#### **Use Cases:**
```
‚úÖ ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ (‡∏Ñ‡∏ì‡∏¥‡∏ï): ‡∏™‡∏≠‡∏ô‡∏´‡πâ‡∏≠‡∏á 201 ‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏™‡∏°‡∏≠
‚úÖ ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á (‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢): ‡∏™‡∏≠‡∏ô‡∏´‡πâ‡∏≠‡∏á 305 ‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏™‡∏°‡∏≠
‚úÖ ‡∏Ñ‡∏£‡∏π‡∏û‡∏•‡∏∞: ‡πÉ‡∏ä‡πâ‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏µ‡∏¨‡∏≤‡πÄ‡∏™‡∏°‡∏≠
‚úÖ ‡∏Ñ‡∏£‡∏π Computer: ‡πÉ‡∏ä‡πâ‡∏´‡πâ‡∏≠‡∏á Computer Lab 1 ‡πÄ‡∏™‡∏°‡∏≠

‚ùå ‡∏Ñ‡∏£‡∏π‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏à‡∏≥ (‡πÉ‡∏ä‡πâ‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô)
```

#### **Database Schema:**

```sql
-- New table: Instructor Room Assignments
CREATE TABLE instructor_room_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instructor_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    academic_year_id UUID NOT NULL REFERENCES academic_years(id) ON DELETE CASCADE,
    
    -- Priority
    is_preferred BOOLEAN DEFAULT false,  -- ‡∏ä‡∏≠‡∏ö‡πÉ‡∏ä‡πâ‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ (soft)
    is_required BOOLEAN DEFAULT false,   -- ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ (hard)
    
    -- Conditions
    for_subjects JSONB DEFAULT '[]'::jsonb, -- ‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏¥‡∏ä‡∏≤ [], null=‡∏ó‡∏∏‡∏Å‡∏ß‡∏¥‡∏ä‡∏≤
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Unique: instructor can have multiple room assignments
    CONSTRAINT unique_instructor_room_year UNIQUE(instructor_id, room_id, academic_year_id)
);

CREATE INDEX idx_instructor_room_instructor ON instructor_room_assignments(instructor_id);
CREATE INDEX idx_instructor_room_room ON instructor_room_assignments(room_id);

-- Examples:
INSERT INTO instructor_room_assignments (
    instructor_id, room_id, academic_year_id,
    is_required, for_subjects
) VALUES 
-- ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡∏™‡∏≠‡∏ô‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏á 201 ‡πÄ‡∏™‡∏°‡∏≠
('uuid-teacher-somchai', 'uuid-room-201', 'uuid-year-2568', true, '["MATH"]'),

-- ‡∏Ñ‡∏£‡∏π‡∏û‡∏•‡∏∞ ‡πÉ‡∏ä‡πâ‡∏™‡∏ô‡∏≤‡∏°‡πÄ‡∏™‡∏°‡∏≠
('uuid-teacher-pe', 'uuid-field-1', 'uuid-year-2568', true, '["PE"]'),

-- ‡∏Ñ‡∏£‡∏π‡∏Ñ‡∏≠‡∏° ‡∏ä‡∏≠‡∏ö‡πÉ‡∏ä‡πâ Lab 1 (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)
('uuid-teacher-comp', 'uuid-lab-comp-1', 'uuid-year-2568', false, '["COMPUTER"]');
```

#### **Implementation:**

```rust
struct InstructorRoomAssignment {
    instructor_id: Uuid,
    room_id: Uuid,
    is_required: bool,
    for_subjects: Vec<String>, // Empty = all subjects
}

async fn get_instructor_room_assignment(
    pool: &PgPool,
    instructor_id: Uuid,
    subject_id: Uuid,
) -> Result<Option<InstructorRoomAssignment>, AppError> {
    let assignment = sqlx::query_as::<_, InstructorRoomAssignment>(
        "SELECT * FROM instructor_room_assignments
         WHERE instructor_id = $1
           AND (for_subjects = '[]'::jsonb 
                OR for_subjects @> to_jsonb($2::text))
           AND is_required = true"
    )
    .bind(instructor_id)
    .bind(subject_id.to_string())
    .fetch_optional(pool)
    .await?;
    
    Ok(assignment)
}

fn assign_room_for_course(
    course: &CourseToSchedule,
    assignment: &Assignment,
    instructor_room: &Option<InstructorRoomAssignment>,
) -> Option<Uuid> {
    // Priority 1: Fixed room for instructor
    if let Some(room_assignment) = instructor_room {
        if room_assignment.is_required {
            return Some(room_assignment.room_id);
        }
    }
    
    // Priority 2: Subject requires special room (LAB)
    if let Some(room_type) = &course.required_room_type {
        return find_available_room_by_type(room_type);
    }
    
    // Priority 3: Instructor prefers certain room
    if let Some(room_assignment) = instructor_room {
        if !room_assignment.is_required {
            return Some(room_assignment.room_id);
        }
    }
    
    // Priority 4: Use classroom's default room
    None // NULL = use classroom's home room
}

// Validation: Check if assigned room is available
async fn validate_room_assignment(
    pool: &PgPool,
    assignment: &Assignment,
    instructor_room: &Option<InstructorRoomAssignment>,
) -> Result<(), AppError> {
    let room_id = match instructor_room {
        Some(r) if r.is_required => r.room_id,
        _ => return Ok(()), // No fixed room = OK
    };
    
    // Check if room is available at this time
    let conflict = sqlx::query_scalar::<_, bool>(
        "SELECT EXISTS(
            SELECT 1 FROM academic_timetable_entries
            WHERE room_id = $1
              AND day_of_week = $2
              AND period_id = $3
              AND id != $4
        )"
    )
    .bind(room_id)
    .bind(&assignment.time_slot.day)
    .bind(assignment.time_slot.period_id)
    .bind(assignment.id)
    .fetch_one(pool)
    .await?;
    
    if conflict {
        return Err(AppError::BadRequest(format!(
            "Required room {} is not available at {} {}",
            room_id, assignment.time_slot.day, assignment.time_slot.period_id
        )));
    }
    
    Ok(())
}
```

#### **UI: Setting Instructor Room Assignment**

```svelte
<!-- /staff/academic/instructor-rooms/+page.svelte -->

<script lang="ts">
    let instructors = $state<Instructor[]>([]);
    let rooms = $state<Room[]>([]);
    let assignments = $state<InstructorRoomAssignment[]>([]);
    
    async function assignRoom(instructorId: string, roomId: string, isRequired: boolean) {
        await apiClient.post('/academic/instructor-room-assignments', {
            instructor_id: instructorId,
            room_id: roomId,
            is_required: isRequired,
            for_subjects: [] // All subjects
        });
    }
</script>

<Table>
    <TableHeader>
        <TableRow>
            <TableHead>‡∏Ñ‡∏£‡∏π</TableHead>
            <TableHead>‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏à‡∏≥</TableHead>
            <TableHead>‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö</TableHead>
        </TableRow>
    </TableHeader>
    <TableBody>
        {#each instructors as instructor}
            <TableRow>
                <TableCell>{instructor.name}</TableCell>
                <TableCell>
                    <Select bind:value={instructor.assigned_room_id}>
                        <SelectTrigger>
                            <SelectValue placeholder="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á" />
                        </SelectTrigger>
                        <SelectContent>
                            {#each rooms as room}
                                <SelectItem value={room.id}>{room.code}</SelectItem>
                            {/each}
                        </SelectContent>
                    </Select>
                </TableCell>
                <TableCell>
                    <Checkbox bind:checked={instructor.is_room_required} />
                </TableCell>
            </TableRow>
        {/each}
    </TableBody>
</Table>
```

#### **Examples:**

```rust
// ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡∏™‡∏≠‡∏ô‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏á 201 ‡πÄ‡∏™‡∏°‡∏≠
InstructorRoomAssignment {
    instructor_id: somchai_id,
    room_id: room_201_id,
    is_required: true,
    for_subjects: vec!["MATH".to_string()],
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏°.4/1 ‡∏Ñ‡∏≤‡∏ö 1: ‡∏Ñ‡∏ì‡∏¥‡∏ï (‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢) ‚Üí ‡∏´‡πâ‡∏≠‡∏á 201
‚úÖ ‡∏°.5/2 ‡∏Ñ‡∏≤‡∏ö 3: ‡∏Ñ‡∏ì‡∏¥‡∏ï (‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢) ‚Üí ‡∏´‡πâ‡∏≠‡∏á 201
‚ùå ‡∏°.4/1 ‡∏Ñ‡∏≤‡∏ö 1: ‡∏Ñ‡∏ì‡∏¥‡∏ï (‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢) ‚Üí ‡∏´‡πâ‡∏≠‡∏á 305 (‡∏ú‡∏¥‡∏î! ‡∏ï‡πâ‡∏≠‡∏á 201)

// ‡∏Ñ‡∏£‡∏π‡∏û‡∏•‡∏∞ ‡πÉ‡∏ä‡πâ‡∏™‡∏ô‡∏≤‡∏°‡πÄ‡∏™‡∏°‡∏≠
InstructorRoomAssignment {
    instructor_id: pe_teacher_id,
    room_id: field_id,
    is_required: true,
    for_subjects: vec!["PE".to_string()],
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ñ‡πå:
‚úÖ ‡∏°.4/1 ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏û‡∏•‡∏∞ ‚Üí ‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏µ‡∏¨‡∏≤
‚ùå ‡∏°.4/1 ‡∏Ñ‡∏≤‡∏ö 5-6: ‡∏û‡∏•‡∏∞ ‚Üí ‡∏´‡πâ‡∏≠‡∏á 101 (‡∏ú‡∏¥‡∏î!)
```

**Priority**: üî¥ Critical
**Enforcement**: Hard constraint if `is_required = true`, Soft if `is_preferred = true`

---

### **HC-9: Pre-Assigned / Locked Slots** üî¥ HARD
**‡∏Å‡∏é**: ‡∏ö‡∏≤‡∏á‡∏Ñ‡∏≤‡∏ö‡∏ñ‡∏π‡∏Å lock ‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á

#### **Use Cases:**
```
‚úÖ ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.4 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏û‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏û‡∏∏‡∏ò‡∏Ñ‡∏≤‡∏ö 5-6 (‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î)
‚úÖ ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.1-‡∏°.6 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå‡∏Ñ‡∏≤‡∏ö 1 (‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î)
‚úÖ ‡∏´‡πâ‡∏≠‡∏á ‡∏°.4/1 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡∏Ñ‡∏≤‡∏ö 1 (‡∏ú‡∏π‡πâ‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏¥‡πÄ‡∏®‡∏©)
‚úÖ ‡∏´‡πâ‡∏≠‡∏á ‡∏°.5 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ä‡∏∏‡∏°‡∏ô‡∏∏‡∏°‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™‡∏Ñ‡∏≤‡∏ö 7-8 (‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î)

‚ùå ‡∏ß‡∏¥‡∏ä‡∏≤‡∏≠‡∏∑‡πà‡∏ô ‡πÜ: ‡∏à‡∏±‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÑ‡∏î‡πâ
```

#### **Database Schema:**

```sql
-- New table: Pre-assigned Timetable Slots
CREATE TABLE timetable_locked_slots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    academic_semester_id UUID NOT NULL REFERENCES academic_semesters(id) ON DELETE CASCADE,
    
    -- Scope (‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï)
    scope_type VARCHAR(20) NOT NULL, -- 'CLASSROOM', 'GRADE_LEVEL', 'ALL_SCHOOL'
    scope_ids JSONB, -- classroom_ids or grade_level_ids (null if ALL_SCHOOL)
    
    -- Subject (‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏µ‡πà lock)
    subject_id UUID NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
    
    -- Time (‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà lock)
    day_of_week VARCHAR(3) NOT NULL,
    period_ids JSONB NOT NULL, -- Array of period UUIDs
    
    -- Optional: Room (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏´‡πâ‡∏≠‡∏á)
    room_id UUID REFERENCES rooms(id) ON DELETE SET NULL,
    
    -- Optional: Instructor (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏£‡∏π)
    instructor_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Metadata
    reason TEXT, -- ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ó‡∏µ‡πà lock
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    CONSTRAINT valid_scope CHECK (
        scope_type IN ('CLASSROOM', 'GRADE_LEVEL', 'ALL_SCHOOL')
    )
);

CREATE INDEX idx_locked_slots_semester ON timetable_locked_slots(academic_semester_id);
CREATE INDEX idx_locked_slots_subject ON timetable_locked_slots(subject_id);
CREATE INDEX idx_locked_slots_day ON timetable_locked_slots(day_of_week);

-- Examples:
-- 1. ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.4 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏û‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏û‡∏∏‡∏ò‡∏Ñ‡∏≤‡∏ö 5-6
INSERT INTO timetable_locked_slots (
    academic_semester_id, scope_type, scope_ids,
    subject_id, day_of_week, period_ids, reason
) VALUES (
    'uuid-semester-1-2568',
    'GRADE_LEVEL',
    '["uuid-grade-m4"]'::jsonb,
    'uuid-subject-pe',
    'WED',
    '["uuid-period-5", "uuid-period-6"]'::jsonb,
    '‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ ‡∏°.4 ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏û‡∏•‡∏∞‡∏û‡∏∏‡∏ò‡∏ö‡πà‡∏≤‡∏¢'
);

-- 2. ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå‡∏Ñ‡∏≤‡∏ö 1
INSERT INTO timetable_locked_slots (
    academic_semester_id, scope_type, scope_ids,
    subject_id, day_of_week, period_ids, reason
) VALUES (
    'uuid-semester-1-2568',
    'ALL_SCHOOL',
    null,
    'uuid-subject-guidance',
    'FRI',
    '["uuid-period-1"]'::jsonb,
    '‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß‡∏®‡∏∏‡∏Å‡∏£‡πå‡πÄ‡∏ä‡πâ‡∏≤'
);

-- 3. ‡∏´‡πâ‡∏≠‡∏á ‡∏°.4/1 ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏´‡πâ‡∏≠‡∏á ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡∏Ñ‡∏≤‡∏ö 1
INSERT INTO timetable_locked_slots (
    academic_semester_id, scope_type, scope_ids,
    subject_id, day_of_week, period_ids,
    instructor_id, reason
) VALUES (
    'uuid-semester-1-2568',
    'CLASSROOM',
    '["uuid-classroom-m4-1"]'::jsonb,
    'uuid-subject-math',
    'MON',
    '["uuid-period-1"]'::jsonb,
    'uuid-teacher-somchai',
    '‡∏ú‡∏π‡πâ‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ ‡∏°.4/1 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏Å‡∏±‡∏ö‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡πÄ‡∏ä‡πâ‡∏≤‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô'
);
```

#### **Implementation:**

```rust
struct LockedSlot {
    id: Uuid,
    scope_type: String, // CLASSROOM, GRADE_LEVEL, ALL_SCHOOL
    scope_ids: Vec<Uuid>,
    subject_id: Uuid,
    day_of_week: String,
    period_ids: Vec<Uuid>,
    room_id: Option<Uuid>,
    instructor_id: Option<Uuid>,
}

async fn get_locked_slots(
    pool: &PgPool,
    semester_id: Uuid,
    classroom_id: Option<Uuid>,
    grade_level_id: Option<Uuid>,
) -> Result<Vec<LockedSlot>, AppError> {
    let locked_slots = sqlx::query_as::<_, LockedSlot>(
        "SELECT * FROM timetable_locked_slots
         WHERE academic_semester_id = $1
           AND (
               scope_type = 'ALL_SCHOOL'
               OR (scope_type = 'GRADE_LEVEL' AND scope_ids @> to_jsonb($2::text))
               OR (scope_type = 'CLASSROOM' AND scope_ids @> to_jsonb($3::text))
           )"
    )
    .bind(semester_id)
    .bind(grade_level_id.map(|id| id.to_string()))
    .bind(classroom_id.map(|id| id.to_string()))
    .fetch_all(pool)
    .await?;
    
    Ok(locked_slots)
}

fn apply_locked_slots(
    schedule: &mut Schedule,
    locked_slots: &[LockedSlot],
) -> Result<(), AppError> {
    for locked in locked_slots {
        // For each classroom in scope
        let classroom_ids = match locked.scope_type.as_str() {
            "ALL_SCHOOL" => schedule.get_all_classroom_ids(),
            "GRADE_LEVEL" => schedule.get_classrooms_by_grade(&locked.scope_ids),
            "CLASSROOM" => locked.scope_ids.clone(),
            _ => vec![],
        };
        
        for classroom_id in classroom_ids {
            // Find the course for this subject in this classroom
            let course = schedule.courses.iter()
                .find(|c| c.classroom_id == classroom_id && c.subject_id == locked.subject_id);
            
            if let Some(course) = course {
                // Pre-assign these periods
                for period_id in &locked.period_ids {
                    let assignment = Assignment {
                        course_id: course.id,
                        time_slot: TimeSlot {
                            day: locked.day_of_week.clone(),
                            period_id: *period_id,
                        },
                        room_id: locked.room_id,
                        is_locked: true, // Mark as locked
                    };
                    
                    schedule.add_assignment(assignment)?;
                }
                
                // Reduce required periods for this course
                course.periods_remaining -= locked.period_ids.len() as i32;
            }
        }
    }
    
    Ok(())
}

// During scheduling, skip locked slots
fn is_slot_locked(
    classroom_id: Uuid,
    day: &str,
    period_id: Uuid,
    locked_slots: &[LockedSlot],
) -> bool {
    locked_slots.iter().any(|locked| {
        // Check if this slot is locked for this classroom
        let is_in_scope = match locked.scope_type.as_str() {
            "ALL_SCHOOL" => true,
            "GRADE_LEVEL" => {
                // Check if classroom belongs to this grade
                locked.scope_ids.contains(&get_grade_level_id(classroom_id))
            },
            "CLASSROOM" => locked.scope_ids.contains(&classroom_id),
            _ => false,
        };
        
        // Check if day and period match
        is_in_scope 
            && locked.day_of_week == day 
            && locked.period_ids.contains(&period_id)
    })
}

// Modified scheduling algorithm
async fn schedule_with_locked_slots(
    pool: &PgPool,
    classroom_ids: &[Uuid],
    semester_id: Uuid,
) -> Result<Schedule, AppError> {
    // 1. Get locked slots
    let locked_slots = get_locked_slots(pool, semester_id, None, None).await?;
    
    // 2. Create initial schedule with locked slots
    let mut schedule = Schedule::new();
    apply_locked_slots(&mut schedule, &locked_slots)?;
    
    // 3. Get remaining courses to schedule
    let remaining_courses = get_remaining_courses(&schedule);
    
    // 4. Schedule remaining courses (avoiding locked slots)
    for course in remaining_courses {
        for slot in available_slots {
            // Skip if slot is locked
            if is_slot_locked(course.classroom_id, &slot.day, slot.period_id, &locked_slots) {
                continue;
            }
            
            // Try to assign
            if can_assign(course, slot, &schedule) {
                schedule.add_assignment(create_assignment(course, slot))?;
            }
        }
    }
    
    Ok(schedule)
}
```

#### **UI: Locking Slots**

```svelte
<!-- Component: LockSlotDialog -->

<script lang="ts">
    let scopeType = $state<'CLASSROOM' | 'GRADE_LEVEL' | 'ALL_SCHOOL'>('GRADE_LEVEL');
    let selectedIds = $state<string[]>([]);
    let selectedSubject = $state<string>('');
    let selectedDay = $state<string>('MON');
    let selectedPeriods = $state<string[]>([]);
    
    async function lockSlot() {
        await apiClient.post('/academic/timetable/lock-slot', {
            scope_type: scopeType,
            scope_ids: scopeType === 'ALL_SCHOOL' ? null : selectedIds,
            subject_id: selectedSubject,
            day_of_week: selectedDay,
            period_ids: selectedPeriods,
            reason: reason
        });
    }
</script>

<Dialog.Root>
    <Dialog.Content class="max-w-2xl">
        <Dialog.Header>
            <Dialog.Title>üîí Lock ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞</Dialog.Title>
        </Dialog.Header>
        
        <div class="space-y-4">
            <!-- Scope Selection -->
            <div>
                <Label.Root>‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï</Label.Root>
                <Select.Root bind:value={scopeType}>
                    <Select.Trigger>
                        <Select.Value />
                    </Select.Trigger>
                    <Select.Content>
                        <Select.Item value="CLASSROOM">‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞</Select.Item>
                        <Select.Item value="GRADE_LEVEL">‡∏ó‡∏±‡πâ‡∏á‡∏ä‡∏±‡πâ‡∏ô (‡πÄ‡∏ä‡πà‡∏ô ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.4)</Select.Item>
                        <Select.Item value="ALL_SCHOOL">‡∏ó‡∏±‡πâ‡∏á‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô</Select.Item>
                    </Select.Content>
                </Select.Root>
            </div>
            
            <!-- Classroom/Grade Selection (if not ALL_SCHOOL) -->
            {#if scopeType !== 'ALL_SCHOOL'}
                <div>
                    <Label.Root>
                        {scopeType === 'CLASSROOM' ? '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô' : '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô'}
                    </Label.Root>
                    <!-- Multi-select component -->
                </div>
            {/if}
            
            <!-- Subject Selection -->
            <div>
                <Label.Root>‡∏ß‡∏¥‡∏ä‡∏≤</Label.Root>
                <Select.Root bind:value={selectedSubject}>
                    <!-- Subject options -->
                </Select.Root>
            </div>
            
            <!-- Day Selection -->
            <div>
                <Label.Root>‡∏ß‡∏±‡∏ô</Label.Root>
                <Select.Root bind:value={selectedDay}>
                    <Select.Item value="MON">‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå</Select.Item>
                    <Select.Item value="TUE">‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£</Select.Item>
                    <!-- ... -->
                </Select.Root>
            </div>
            
            <!-- Period Selection (Multi-select) -->
            <div>
                <Label.Root>‡∏Ñ‡∏≤‡∏ö</Label.Root>
                <div class="grid grid-cols-4 gap-2">
                    {#each periods as period}
                        <label class="flex items-center gap-2">
                            <Checkbox
                                checked={selectedPeriods.includes(period.id)}
                                onCheckedChange={(checked) => {
                                    if (checked) {
                                        selectedPeriods = [...selectedPeriods, period.id];
                                    } else {
                                        selectedPeriods = selectedPeriods.filter(p => p !== period.id);
                                    }
                                }}
                            />
                            <span>{period.name}</span>
                        </label>
                    {/each}
                </div>
            </div>
            
            <!-- Reason -->
            <div>
                <Label.Root>‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•</Label.Root>
                <Textarea bind:value={reason} placeholder="‡πÄ‡∏ä‡πà‡∏ô ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î..." />
            </div>
        </div>
        
        <Dialog.Footer>
            <Button onclick={lockSlot}>üîí Lock ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ</Button>
        </Dialog.Footer>
    </Dialog.Content>
</Dialog.Root>

<!-- Locked Slots List -->
<Card>
    <CardHeader>
        <CardTitle>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å Lock</CardTitle>
    </CardHeader>
    <CardContent>
        <Table>
            <TableHeader>
                <TableRow>
                    <TableHead>‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï</TableHead>
                    <TableHead>‡∏ß‡∏¥‡∏ä‡∏≤</TableHead>
                    <TableHead>‡∏ß‡∏±‡∏ô-‡∏Ñ‡∏≤‡∏ö</TableHead>
                    <TableHead>‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•</TableHead>
                    <TableHead></TableHead>
                </TableRow>
            </TableHeader>
            <TableBody>
                {#each lockedSlots as slot}
                    <TableRow>
                        <TableCell>{getScopeDisplay(slot)}</TableCell>
                        <TableCell>{slot.subject_name}</TableCell>
                        <TableCell>{slot.day} ‡∏Ñ‡∏≤‡∏ö {slot.periods.join(', ')}</TableCell>
                        <TableCell class="text-sm text-muted-foreground">{slot.reason}</TableCell>
                        <TableCell>
                            <Button variant="ghost" size="icon" onclick={() => unlockSlot(slot.id)}>
                                <Trash2 class="w-4 h-4" />
                            </Button>
                        </TableCell>
                    </TableRow>
                {/each}
            </TableBody>
        </Table>
    </CardContent>
</Card>
```

#### **Examples:**

```rust
// Example 1: ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.4 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏û‡∏•‡∏∞‡∏û‡∏∏‡∏ò‡∏ö‡πà‡∏≤‡∏¢
LockedSlot {
    scope_type: "GRADE_LEVEL",
    scope_ids: vec![m4_grade_id],
    subject_id: pe_subject_id,
    day_of_week: "WED",
    period_ids: vec![period_5_id, period_6_id],
    reason: "‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î",
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:
‚úÖ ‡∏°.4/1: ‡∏û‡∏∏‡∏ò 13:00-15:00 ‡∏û‡∏•‡∏∞
‚úÖ ‡∏°.4/2: ‡∏û‡∏∏‡∏ò 13:00-15:00 ‡∏û‡∏•‡∏∞
‚úÖ ‡∏°.4/3: ‡∏û‡∏∏‡∏ò 13:00-15:00 ‡∏û‡∏•‡∏∞
‚ùå ‡∏£‡∏∞‡∏ö‡∏ö Auto ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏à‡∏±‡∏î‡∏ß‡∏¥‡∏ä‡∏≤‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ‡∏°.4 ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á

// Example 2: ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß‡∏®‡∏∏‡∏Å‡∏£‡πå‡πÄ‡∏ä‡πâ‡∏≤
LockedSlot {
    scope_type: "ALL_SCHOOL",
    scope_ids: vec![],
    subject_id: guidance_subject_id,
    day_of_week: "FRI",
    period_ids: vec![period_1_id],
    reason: "‡∏ô‡πÇ‡∏¢‡∏ö‡∏≤‡∏¢‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô",
}

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ñ‡πå:
‚úÖ ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.1-‡∏°.6: ‡∏®‡∏∏‡∏Å‡∏£‡πå ‡∏Ñ‡∏≤‡∏ö 1 ‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß
‚ùå ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏à‡∏±‡∏î‡∏ß‡∏¥‡∏ä‡∏≤‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå‡∏Ñ‡∏≤‡∏ö 1 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á
```

**Priority**: üî¥ Absolute (highest)
**Enforcement**: Must respect locked slots, cannot override

---

## üìä Summary: Advanced Constraints

| ID | Constraint | Type | Example | Can Override? |
|----|-----------|------|---------|---------------|
| HC-7 | Consecutive Periods | Hard | ‡∏û‡∏•‡∏∞ 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î | ‚ùå No |
| HC-8 | Fixed Room | Hard | ‡∏Ñ‡∏£‡∏π A ‚Üí ‡∏´‡πâ‡∏≠‡∏á 201 | ‚ùå No (if required) |
| HC-9 | Locked Slots | Hard | ‡∏°.4 ‡∏û‡∏•‡∏∞‡∏û‡∏∏‡∏ò‡∏ö‡πà‡∏≤‡∏¢ | ‚ùå Never |

---

## üîÑ Modified Scheduling Flow

```rust
async fn auto_schedule_with_advanced_constraints(
    pool: &PgPool,
    classroom_ids: &[Uuid],
    semester_id: Uuid,
) -> Result<Schedule, AppError> {
    // 1. Get all constraints
    let consecutive_reqs = get_consecutive_requirements(pool).await?;
    let instructor_rooms = get_instructor_room_assignments(pool).await?;
    let locked_slots = get_locked_slots(pool, semester_id, None, None).await?;
    
    // 2. Create schedule with locked slots first
    let mut schedule = Schedule::new();
    apply_locked_slots(&mut schedule, &locked_slots)?;
    
    // 3. Get remaining courses
    let mut courses = get_remaining_courses(pool, classroom_ids, semester_id, &schedule).await?;
    
    // 4. Sort by difficulty (considering consecutive requirements)
    courses.sort_by_key(|c| {
        let mut difficulty = 0;
        
        // Has consecutive requirement = more difficult
        if let Some(req) = consecutive_reqs.get(&c.subject_id) {
            if req.min_consecutive > 1 {
                difficulty += 100;
            }
        }
        
        // Has fixed room = more difficult
        if instructor_rooms.get(&c.instructor_id).is_some() {
            difficulty += 50;
        }
        
        // More periods = more difficult
        difficulty += c.periods_needed * 10;
        
        -difficulty // Reverse sort
    });
    
    // 5. Schedule each course
    for course in courses {
        // Get consecutive requirement
        let consecutive_req = consecutive_reqs.get(&course.subject_id);
        
        // Get fixed room
        let instructor_room = instructor_rooms.get(&course.instructor_id);
        
        // Try to schedule
        let assignments = schedule_course_with_constraints(
            &course,
            &schedule,
            consecutive_req,
            instructor_room,
            &locked_slots,
        )?;
        
        schedule.add_assignments(assignments)?;
    }
    
    // 6. Validate
    validate_schedule(&schedule)?;
    
    Ok(schedule)
}
```

---

## üéØ Complete Example

```rust
// ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏°‡∏µ‡∏Å‡∏≥‡∏´‡∏ô‡∏î:
// 1. ‡∏ó‡∏∏‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡∏°.4 ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏û‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏û‡∏∏‡∏ò‡∏Ñ‡∏≤‡∏ö 5-6 (LOCKED)
// 2. ‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ (‡∏Ñ‡∏ì‡∏¥‡∏ï) ‡∏™‡∏≠‡∏ô‡∏´‡πâ‡∏≠‡∏á 201 ‡∏õ‡∏£‡∏∞‡∏à‡∏≥ (FIXED ROOM)
// 3. ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏°‡∏µ ‡∏ï‡πâ‡∏≠‡∏á 2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î (CONSECUTIVE)

let config = SchedulingConfig {
    locked_slots: vec![
        LockedSlot {
            scope_type: "GRADE_LEVEL",
            scope_ids: vec![m4_grade_id],
            subject: "PE",
            day: "WED",
            periods: vec![5, 6],
        }
    ],
    instructor_rooms: vec![
        InstructorRoom {
            instructor: "‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢",
            room: "201",
            required: true,
        }
    ],
    consecutive_requirements: vec![
        ConsecutiveReq {
            subject: "‡πÄ‡∏Ñ‡∏°‡∏µ LAB",
            min: 2,
            max: 2,
            force: true,
        }
    ],
};

let result = auto_schedule(classroom_ids, semester_id, config).await?;

// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå ‡∏°.4/1:
‚úÖ ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå 08:00 ‡∏Ñ‡∏ì‡∏¥‡∏ï (‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡∏´‡πâ‡∏≠‡∏á 201) ‚Üê Fixed room
‚úÖ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ 10:00-11:40 ‡πÄ‡∏Ñ‡∏°‡∏µ LAB (2 ‡∏Ñ‡∏≤‡∏ö‡∏ï‡∏¥‡∏î) ‚Üê Consecutive
‚úÖ ‡∏û‡∏∏‡∏ò 13:00-15:00 ‡∏û‡∏•‡∏∞ (LOCKED) ‚Üê Pre-assigned
‚úÖ ‡∏û‡∏§‡∏´‡∏±‡∏™ 09:00 ‡∏Ñ‡∏ì‡∏¥‡∏ï (‡∏Ñ‡∏£‡∏π‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡∏´‡πâ‡∏≠‡∏á 201) ‚Üê Fixed room
‚úÖ ...etc
```

---

**‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏à‡∏≤‡∏Å‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å**: `timetable_constraints_specification.md`

**Version**: 1.1
**Last Updated**: 2026-02-08
**Author**: SchoolOrbit Development Team
